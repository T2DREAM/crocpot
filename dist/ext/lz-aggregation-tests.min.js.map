{"version":3,"sources":["lz-aggregation-tests.min.js"],"names":["root","factory","define","amd","LocusZoom","raremetal","Q","module","exports","require","ext","Data","sources","Object","keys","forEach","key","this","AggregationTestSource","Source","extend","init","parseInit","prototype","getURL","state","chain","fields","required_info","aggregation_tests","header","aggregation_genoset_id","genoset_id","aggregation_genoset_build","genoset_build","aggregation_phenoset_id","phenoset_id","aggregation_pheno","pheno","aggregation_calcs","calcs","aggregation_masks","masks","url","getCacheKey","JSON","stringify","chrom","chr","start","stop","end","genotypeDataset","phenotypeDataset","phenotype","samples","genomeBuild","fetchRequest","body","createCORSPromise","Content-Type","annotateData","records","groups","variants","filter","item","groupType","parsed","helpers","parsePortalJSON","byMask","length","results","runner","PortalTestRunner","res","toJSON","e","console","error","Error","data","normalizeResponse","combineChainBody","AssocFromAggregationLZ","KnownDataSources","from","params","_from","getRequest","discrete","self","constructor","SOURCE_NAME","when","parse","REGEX_EPACTS","RegExp","map","one_variant","match","variant","chromosome","position","ref_allele","ref_allele_freq","altFreq","log_pvalue","Math","log10","pvalue","sort","a","b","GeneAggregationConnectorLZ","REQUIRED_SOURCES","aggregation_source_id","_source_name_mapping","gene_source_id","aggregationData","genesData","groupedAggregation","result","hasOwnProperty","group","push","gene","gene_id","gene_name","tests","aggregation_best_pvalue","min","apply"],"mappings":"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","file":"lz-aggregation-tests.min.js","sourcesContent":["'use strict';\n/*\n * LocusZoom extensions used to calculate and render aggregation test results. Because these calculations depend on an\n *   external library, the special data sources are defined here, rather than in LocusZoom core code.\n *\n *     The page must incorporate and load all libraries before this file can be used, including:\n *    - Vendor assets\n *    - LocusZoom\n *    - raremetal.js (available via NPM or a related CDN)\n */\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n// Arcane build note: everything defined here gets registered globally. This is not a \"pure\" module, and some build\n//  systems may require being told that this file has side effects.\n/* global define, module, require */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['locuszoom', 'raremetal.js', 'q'] , function(LocusZoom, raremetal, Q) {  // amd\n            return factory(LocusZoom, raremetal, Q);\n        });\n    } else if(typeof module === 'object' && module.exports) {  // commonJS\n        module.exports = factory(require('locuszoom'), require('raremetal.js'), require('q'));\n    } else {  // globals\n        if (!root.LocusZoom.ext.Data) {\n            root.LocusZoom.ext.Data = {};\n        }\n        var sources = factory(root.LocusZoom, root.raremetal, root.Q);\n        Object.keys(sources).forEach(function(key) {\n            root.LocusZoom.ext.Data[key] = sources[key];\n        });\n    }\n}(this, function(LocusZoom, raremetal, Q) {\n    /**\n     * Data Source that calculates gene or region-based tests based on provided data\n     *   It will rarely be used by itself, but rather using a connector that attaches the results to data from\n     *   another source (like genes). Using a separate connector allows us to add caching and run this front-end\n     *   calculation only once, while using it in many different places\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var AggregationTestSource = LocusZoom.Data.Source.extend(function (init) {\n        this.parseInit(init);\n    }, 'AggregationTestSourceLZ');\n\n    AggregationTestSource.prototype.getURL = function (state, chain, fields) {\n        // Unlike most sources, calculations may require access to plot state data even after the initial request\n        // This example source REQUIRES that the external UI widget would store the needed test definitions in a plot state\n        //  field called `aggregation_tests` (an object {masks: [], calcs: {})\n        var required_info = state.aggregation_tests || {};\n\n        if (!chain.header) {\n            chain.header = {};\n        }\n        // All of these fields are required in order to use this datasource. TODO: Add validation?\n        chain.header.aggregation_genoset_id = required_info.genoset_id || null;\n        chain.header.aggregation_genoset_build = required_info.genoset_build || null;\n        chain.header.aggregation_phenoset_id = required_info.phenoset_id || null;\n        chain.header.aggregation_pheno = required_info.pheno || null;\n        chain.header.aggregation_calcs = required_info.calcs || {};\n        chain.header.aggregation_masks = required_info.masks || [];\n        return this.url;\n    };\n\n    AggregationTestSource.prototype.getCacheKey = function (state, chain, fields) {\n        this.getURL(state, chain, fields);  // TODO: This just sets the chain.header fields\n        return JSON.stringify({\n            chrom: state.chr,\n            start: state.start,\n            stop: state.end,\n            genotypeDataset: chain.header.aggregation_genoset_id,\n            phenotypeDataset: chain.header.aggregation_phenoset_id,\n            phenotype: chain.header.aggregation_pheno,\n            samples: 'ALL',\n            genomeBuild: chain.header.aggregation_genoset_build,\n            masks: chain.header.aggregation_masks,\n        });\n    };\n\n\n    AggregationTestSource.prototype.fetchRequest = function (state, chain, fields) {\n        var url = this.getURL(state, chain, fields);\n        var body = this.getCacheKey(state, chain, fields);\n        var headers = {\n            'Content-Type': 'application/json'\n        };\n        return LocusZoom.createCORSPromise('POST', url, body, headers);\n    };\n\n    AggregationTestSource.prototype.annotateData = function (records, chain) {\n        // Operate on the calculated results. The result of this method will be added to chain.discrete\n\n        // In a page using live API data, the UI would only request the masks it needs from the API.\n        // But in our demos, sometimes boilerplate JSON has more masks than the UI asked for. Limit what calcs we run (by\n        //  type, and to the set of groups requested by the user)\n\n        // The Raremetal-server API has a quirk: it returns a different payload structure if no groups are defined\n        //  for the request region. Detect when that happens and end the calculation immediately in that case\n        if (!records.groups) {\n            return { groups: [], variants: [] };\n        }\n\n        records.groups = records.groups.filter(function (item) {\n            return item.groupType === 'GENE';\n        });\n\n        var parsed = raremetal.helpers.parsePortalJSON(records);\n        var groups = parsed[0];\n        var variants = parsed[1];\n\n        groups = groups.byMask(chain.header.aggregation_masks);\n\n        var calcs = chain.header.aggregation_calcs;\n\n        if (!calcs || Object.keys(calcs).length === 0) {\n            // If no calcs have been requested, then return a dummy placeholder immediately\n            return { variants: [], groups: [], results: [] };\n        }\n        var runner = new raremetal.helpers.PortalTestRunner(groups, variants, calcs);\n        try {\n            var res = runner.toJSON();\n        } catch (e) {\n            console.error(e);\n            throw new Error('Failed to calculate aggregation test results');\n        }\n\n        return res.data;\n    };\n\n    AggregationTestSource.prototype.normalizeResponse = function (data) {\n        return data;\n    };\n\n    AggregationTestSource.prototype.combineChainBody = function (records, chain) {\n        // aggregation tests are a bit unique, in that the data is rarely used directly- instead it is used to annotate many\n        //  other layers in different ways. The calculated result has been added to `chain.discrete`, but will not be returned\n        //  as part of the response body built up by the chain\n        return chain.body;\n    };\n\n\n    /**\n     * A custom data source that reformats existing association data, rather than requesting new data from the server.\n     *  In this case, aggregation test calculations have already made data about variants available, and that data only\n     *  needs to be reformatted to work with the association data layer.\n     *\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var AssocFromAggregationLZ = LocusZoom.KnownDataSources.extend('AssociationLZ', 'AssocFromAggregationLZ', {\n        parseInit: function (init) {\n            if (!init || !init.from) {\n                throw 'Must specify the name of the source that contains association data';\n            }\n            this.params = init.params || {};\n            this._from = init.from;\n        },\n\n        getRequest: function (state, chain, fields) {\n            // Does not actually make a request. Just pick off the specific bundle of data from a known payload structure.\n            if (chain.discrete && !chain.discrete[this._from]) {\n                throw self.constructor.SOURCE_NAME + ' cannot be used before loading required data for: ' + this._from;\n            }\n            // Copy the data so that mutations (like sorting) don't affect the original\n            return Q.when(JSON.parse(JSON.stringify(chain.discrete[this._from]['variants'])));\n        },\n\n        normalizeResponse: function (data) {\n            // The payload structure of the association source is slightly different than the one required by association\n            //   plots. For example, we need to parse variant names and convert to log_pvalue\n            var REGEX_EPACTS = new RegExp('(?:chr)?(.+):(\\\\d+)_?(\\\\w+)?/?([^_]+)?_?(.*)?');  // match API variant strings\n            return data.map(function (one_variant) {\n                var match = one_variant.variant.match(REGEX_EPACTS);\n                return {\n                    variant: one_variant.variant,\n                    chromosome: match[1],\n                    position: +match[2],\n                    ref_allele: match[3],\n                    ref_allele_freq: 1 - one_variant.altFreq,\n                    log_pvalue: -Math.log10(one_variant.pvalue)\n                };\n            }).sort(function (a, b) {\n                a = a.variant;\n                b = b.variant;\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                } else {\n                    // names must be equal\n                    return 0;\n                }\n            });\n        }\n    });\n\n\n    /**\n     * A sample connector that aligns calculated aggregation test data with corresponding gene information. Returns a body\n     *   suitable for use with the genes datalayer.\n     *\n     *  To use this source, one must specify a fields array that calls first the genes source, then a dummy field from\n     *      this source. The output will be to transparently add several new fields to the genes data.\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var GeneAggregationConnectorLZ = LocusZoom.KnownDataSources.extend('ConnectorSource', 'GeneAggregationConnectorLZ', {\n        REQUIRED_SOURCES: ['gene_ns', 'aggregation_ns'],\n        combineChainBody: function (data, chain) {\n            // The genes layer receives all results, and displays only the best pvalue for each gene\n\n            // Tie the calculated group-test results to genes with a matching name\n            var aggregation_source_id = this._source_name_mapping['aggregation_ns'];\n            var gene_source_id = this._source_name_mapping['gene_ns'];\n            // This connector assumes that genes are the main body of records from the chain, and that aggregation tests are\n            //   a standalone source that has not acted on genes data yet\n            var aggregationData = chain.discrete[aggregation_source_id];\n            var genesData = chain.discrete[gene_source_id];\n\n            var groupedAggregation = {};  // Group together all tests done on that gene- any mask, any test\n\n            aggregationData.groups.forEach(function (result) {\n                if (!groupedAggregation.hasOwnProperty(result.group)) {\n                    groupedAggregation[result.group] = [];\n                }\n                groupedAggregation[result.group].push(result.pvalue);\n            });\n\n            // Annotate any genes that have test results\n            genesData.forEach(function (gene) {\n                var gene_id = gene.gene_name;\n                var tests = groupedAggregation[gene_id];\n                if (tests) {\n                    gene.aggregation_best_pvalue = Math.min.apply(null, tests);\n                }\n            });\n            return genesData;\n        }\n    });\n\n\n    // Public interface for this extension; since everything is registered w/LocusZoom, this is rarely used directly.\n    return {\n        AggregationTestSource: AggregationTestSource,\n        AssocFromAggregationLZ: AssocFromAggregationLZ,\n        GeneAggregationConnectorLZ: GeneAggregationConnectorLZ\n    };\n}));\n"]}